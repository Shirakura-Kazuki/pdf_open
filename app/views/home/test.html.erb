<!DOCTYPE html>
<html>
  <head>
    <base target="_top">
    <style>
      * {
        margin: 0;
        padding: 0;
        overflow: hidden;
        height:100vh;
      }
      iframe {
        border:none;
        width:100%;
        height:100%;
      }
    </style>
  </head>

  <body>
    <!-- 新しいコード：public/temp/download.pdfをiframeで表示、存在しない場合はdefault.pdfを表示 -->
  <%# <iframe id="newPdfFrame" src="/temp/download.pdf" onerror="this.onerror=null; this.src='/temp/default.pdf'" width="600" height="500"></iframe> %>
  <%# <iframe id="newPdfFrame" src="/temp/default.pdf" width="600" height="500"></iframe> %>

  <script>
    // PDFの再読み込みと削除処理
    window.onload = function() {
      setTimeout(function(){
        fetch('/delete_pdf', {
          method: 'DELETE'
        })
        .then(() => {
          // PDFを再読み込み
          document.getElementById("newPdfFrame").src = "/temp/download.pdf";
        })
        .catch(() => {
          // エラーが発生した場合は、default.pdfを表示
          document.getElementById("newPdfFrame").src = "/temp/default.pdf";
        });
      }, 60000); // 5分後
    };
  </script>

  <%# Pusherを通じてリアルタイムにPDFのURLを受け取り、そのURLをページ内の特定の要素に適用して、PDFを表示したり、リンクとして提供したりする動作 %>
      <iframe id="content" src="https://drive.google.com/file/d/1iZnyc-l0SIIwhd78N7Dd2593Soilqggs/preview"></iframe>
  
   
   <script>
    <script>
        //ページロード完了時に関数を実行する
        document.addEventListener("DOMContentLoaded", function() {
            // Pusherのインスタンスを作成
            var pusher = new Pusher('32f2640be6b94e4b6afe', {
            cluster: 'ap3'
            });
            //my-channel:サブスクライブ（このチャンネルのevent通知をうけとる）
            var channel = pusher.subscribe('my-channel');
            //my-event:`my-channel`の要素（dataはイベントと共に送信されたデータ）：`data.message`にPDFのURL
            channel.bind('my-event', function(data) {
                
            // 受け取ったPDFのURLをiframeのsrc属性に設定
            document.getElementById('content').src = data.message;

            // 通知を表示（例：alert box）
            alert("新しいPDFがあります");

            // 5秒後に通知を消す
            setTimeout(function() {
                // ここに通知を消すためのコードを書く
                // 例：alert boxなら何もしなくて良い
            }, 5000);  // 5000ミリ秒＝5秒

            });
        });
    </script>


    </body>
</html>






    <!--
    <-- 初期値として指定されたURLをsrc属性に設定 
    <iframe id="content" src="https://drive.google.com/file/d/1iZnyc-l0SIIwhd78N7Dd2593Soilqggs/preview"></iframe>
    
    <%# Pusherを通じてリアルタイムにPDFのURLを受け取り、そのURLをページ内の特定の要素に適用して、PDFを表示したり、リンクとして提供したりする動作 %>
    <script>
    //ページロード完了時に関数を実行する
    document.addEventListener("DOMContentLoaded", function() {
        // Pusherのインスタンスを作成
        var pusher = new Pusher('32f2640be6b94e4b6afe', {
        cluster: 'ap3'
        });
        //my-channel:サブスクライブ（このチャンネルのevent通知をうけとる）
        var channel = pusher.subscribe('my-channel');
        //my-event:`my-channel`の要素（dataはイベントと共に送信されたデータ）：`data.message`にPDFのURL
        channel.bind('my-event', function(data) {
            
        // 受け取ったPDFのURLをiframeのsrc属性に設定
        //ID:`content`（`iframe`:`src`属性):受け取った`data.message`（PDFのURL）に設定。これにより、`iframe`で指定されたURLのコンテンツが表示されます。
        document.getElementById('content').src = data.message;

        });
    });
    </script>
    -->

    <!-- 既存のコード -->
<%# ... ここに既存のコードが続く ... %>

<!-- 新しいコード：public/temp/download.pdfをiframeで表示 -->
<%# <iframe id="newPdfFrame" src="/temp/download.pdf" width="600" height="500"></iframe> %>





<!-- JavaScript to delete the PDF after 5 minutes 
<script>
  window.onload = function() {
    setTimeout(function(){
      fetch('/delete_pdf', {
        method: 'DELETE'
      });
    }, 60000); // 5 minutes
  };
</script>

-->







<!--
  <!DOCTYPE html>
  <html>
    <head>
      <base target="_top">
      <style>
        * {
          margin: 0;
          padding: 0;
          overflow: hidden;
          height:100vh;
        }
        iframe {
          border:none;
          width:100%;
          height:100%;
        }
      </style>
    </head>
    <body>
-->
      <!-- 初期値として指定されたURLをsrc属性に設定 
      <iframe id="content" src="https://drive.google.com/file/d/1iZnyc-l0SIIwhd78N7Dd2593Soilqggs/preview"></iframe>
      
      <%# Pusherを通じてリアルタイムにPDFのURLを受け取り、そのURLをページ内の特定の要素に適用して、PDFを表示したり、リンクとして提供したりする動作 %>
      <script>
      //ページロード完了時に関数を実行する
      document.addEventListener("DOMContentLoaded", function() {
          // Pusherのインスタンスを作成
          var pusher = new Pusher('32f2640be6b94e4b6afe', {
          cluster: 'ap3'
          });
          //my-channel:サブスクライブ（このチャンネルのevent通知をうけとる）
          var channel = pusher.subscribe('my-channel');
          //my-event:`my-channel`の要素（dataはイベントと共に送信されたデータ）：`data.message`にPDFのURL
          channel.bind('my-event', function(data) {
              
          // 受け取ったPDFのURLをiframeのsrc属性に設定
          //ID:`content`（`iframe`:`src`属性):受け取った`data.message`（PDFのURL）に設定。これにより、`iframe`で指定されたURLのコンテンツが表示されます。
          document.getElementById('content').src = data.message;

          });
      });
      </script>
    </body>
  </html>
  -->

// webリサーチ

#### fetch部分

```javascript
fetch('/delete_pdf', {
  method: 'DELETE'
})
```

- 

#### then部分

```javascript
.then(() => {
  // PDFを再読み込み
  document.getElementById("newPdfFrame").src = "/temp/download.pdf";
})
```

- `.then()`は、`fetch()`でのリクエストが成功した場合に実行される処理を指定します。
- `document.getElementById("newPdfFrame").src = "/temp/download.pdf";`: IDが`newPdfFrame`の`iframe`の`src`属性を`/temp/download.pdf`に変更して、新しいPDFを読み込みます。

#### catch部分

```javascript
.catch(() => {
  // エラーが発生した場合は、default.pdfを表示
  document.getElementById("newPdfFrame").src = "/temp/default.pdf";
});
```

- `.catch()`は、`fetch()`でのリクエストが失敗した場合に実行される処理を指定します。
- エラーが発生した場合、IDが`newPdfFrame`の`iframe`の`src`属性を`/temp/default.pdf`に設定して、デフォルトのPDFを表示します。

このスクリプトは、ページが読み込まれた1分後に`/delete_pdf`へDELETEリクエストを送り、成功すれば新しいPDFを、失敗すればデフォルトのPDFを`iframe`に表示するという動きをしま


了解しました。順序を逆にするには、JavaScriptの`Promise`を使って、PDFの読み込みや表示が完了した後に`/delete_pdf`への呼び出しを行うようにコードを変更できます。

以下は、そのように変更したコードの例です。

```html
<iframe id="content" src='/temp/default.pdf'></iframe>
<script>
  // PDFの再読み込みと削除処理
  window.onload = function() {
    setTimeout(function(){
      // 先にPDFを再読み込みか、default.pdfを表示
      let newPdfFrame = document.getElementById("content"); // HTMLのiframeのIDを"content"に合わせました
      newPdfFrame.src = "/temp/download.pdf"; // ここでは仮に新しいPDFを読み込むとしています
      
      // PDFの読み込みが完了したら、次の処理に移る
      newPdfFrame.onload = function() {
        // (/delete_pdf):リクエスト送信：DELETEメソッドであることを指定しています。
        fetch('/delete_pdf', {
          method: 'DELETE'
        })
        .then(() => {
          console.log("delete_pdf成功");
        })
        .catch(() => {
          console.log("delete_pdf失敗");
        });
      };

    }, 60000); // 1分後
  };
</script>
```

このコードでは以下の順序で動作します：

1. ページが読み込まれた1分後に、新しいPDF (`/temp/download.pdf`) を`iframe`に読み込む。
2. 新しいPDFが`iframe`に読み込まれたら、`/delete_pdf`へDELETEリクエストを送る。

このようにすることで、`/delete_pdf`の呼び出しは、PDFの読み込みが完了した後に行われます。



/////////////////////////////////////////////////////////10/16

了解しました。`iframe`の`src`属性を動的に変更するためには、JavaScriptを使って条件に応じて`src`の値を変更する必要があります。

以下のコードは、そのように修正したものです。

```html
<iframe id="content" src='/temp/default.pdf'></iframe>
<script>
  // PDFの表示と削除処理
  window.onload = function() {
    // iframe要素を取得
    let contentFrame = document.getElementById("content");

    // 初期表示は/temp/default.pdf
    contentFrame.src = "/temp/default.pdf";

    // 1分後に実行する処理
    setTimeout(function() {
      // 仮にdownload.pdfが生成されたと仮定して、iframeのsrcを変更
      contentFrame.src = "/temp/download.pdf";

      // download.pdfがiframeに読み込まれたら、次の処理に移る
      contentFrame.onload = function() {
        // (/delete_pdf): DELETEメソッドでリクエスト送信
        fetch('/delete_pdf', {
          method: 'DELETE'
        })
        .then(() => {
          console.log("delete_pdf成功");
        })
        .catch(() => {
          console.log("delete_pdf失敗");
          // エラーが発生した場合は、default.pdfを再表示
          contentFrame.src = "/temp/default.pdf";
        });
      };
    }, 60000); // 1分後
  };
</script>
```

このコードでは以下の順序で動作します：

1. ページが読み込まれたら、`/temp/default.pdf`を`iframe`に読み込む。
2. 1分後、`/temp/download.pdf`を`iframe`に読み込む。
3. `/temp/download.pdf`が`iframe`に読み込まれたら、`/delete_pdf`へDELETEリクエ



// 
   <!-- URL受け渡しversion -->
    <%# <script>
        //ページロード完了時に関数を実行する
        document.addEventListener("DOMContentLoaded", function() {
            // Pusherのインスタンスを作成
            var pusher = new Pusher('32f2640be6b94e4b6afe', {
            cluster: 'ap3'
            });
            //my-channel:サブスクライブ（このチャンネルのevent通知をうけとる）
            var channel = pusher.subscribe('my-channel');
            //my-event:`my-channel`の要素（dataはイベントと共に送信されたデータ）：`data.message`にPDFのURL
            channel.bind('my-event', function(data) {
                
            // 受け取ったPDFのURLをiframeのsrc属性に設定
            document.getElementById('content').src = data.message;

            // 通知を表示（例：alert box）
            alert("新しいPDFがあります");

            // 5秒後に通知を消す
            setTimeout(function() {
                // ここに通知を消すためのコードを書く
                // 例：alert boxなら何もしなくて良い
            }, 5000);  // 5000ミリ秒＝5秒

            });
        });
    </script> %>
      
    <%# // delete_pdf:iframe表示後download.pdfを削除する。
    <script>
      window.onload = function() {
        setTimeout(function(){
          fetch('/delete_pdf', {
            method: 'DELETE'
          });
        }, 300000); // 5 minutes
      };
    </script> %>





<%# 最新 %>
<%# <iframe id="content" src='/temp/default.pdf'></iframe>
    <script>
          puts "settime_off"
        window.onload = function() {
        setTimeout(function(){
          puts "settime_on"
          // 先にPDFを再読み込みか、default.pdfを表示
          let newPdfFrame = document.getElementById("content"); // HTMLのiframeのIDを"content"に合わせました
          newPdfFrame.src = "/temp/download.pdf"; // ここでは仮に新しいPDFを読み込むとしています
          
          PDFの読み込みが完了したら、次の処理に移る
          newPdfFrame.onload = function() {
            (/delete_pdf):リクエスト送信：DELETEメソッドであることを指定しています。
            fetch('/delete_pdf', {
              method: 'DELETE'
            })
            .then(() => {
              console.log("delete_pdf成功");
            })
            .catch(() => {
              console.log("delete_pdf失敗");
            });
          // };

        }, 10000); // 1分後
      };
    </script> %>




    ・・・・・・・・・・・・・・・・・・・
    2回目以降の動作が期待通りでないということですね。問題の原因はいくつか考えられますが、一つの可能性としてJavaScriptの`setTimeout`が一度しか実行されない点が挙げられます。

`setTimeout`は指定した時間が経過した後に一度だけ関数を実行します。繰り返し何かを実行したい場合は、`setInterval`を使用するか、`setTimeout`を再帰的に呼び出す必要があります。

以下のコードは`setInterval`を使用して1分ごとにPDFの表示と削除処理を繰り返すように修正したものです。

```html
<iframe id="content" src='/temp/default.pdf'></iframe>
<script>
  // PDFの表示と削除処理
  window.onload = function() {
    // iframe要素を取得
    let contentFrame = document.getElementById("content");

    // 初期表示は/temp/default.pdf
    contentFrame.src = "/temp/default.pdf";

    // 1分ごとに実行する処理
    setInterval(function() {
      // 仮にdownload.pdfが生成されたと仮定して、iframeのsrcを変更
      contentFrame.src = "/temp/download.pdf";

      // download.pdfがiframeに読み込まれたら、次の処理に移る
      contentFrame.onload = function() {
        // (/delete_pdf): DELETEメソッドでリクエスト送信
        fetch('/delete_pdf', {
          method: 'DELETE'
        })
        .then(() => {
          console.log("delete_pdf成功");
        })
        .catch(() => {
          console.log("delete_pdf失敗");
          // エラーが発生した場合は、default.pdfを再表示
          contentFrame.src = "/temp/default.pdf";
        });
      };
    }, 60000); // 1分ごと
  };
</script>
```

この修正が期待通りの動作をするかどうかお試しください。


//////////////////////////

Railsアプリケーションでは、コントローラーとビューは非常に密接に連携して動作します。基本的な流れは以下の通りです。

1. **ルーティング設定**: `config/routes.rb` ファイルでルート（URLとHTTPメソッドの組み合わせ）を設定します。

    ```ruby
    # config/routes.rb
    Rails.application.routes.draw do
      get 'home/display', to: 'home#display'
    end
    ```

    この設定は、「`http://[ドメイン]/home/display` へのGETリクエストがきたら、`HomeController` の `display` アクションを呼び出せ」と指示しています。

2. **コントローラーの作成**: 対応するコントローラーを作成または編集します。

    ```ruby
    # app/controllers/home_controller.rb
    class HomeController < ApplicationController
      def display
        # 何らかの処理
      end
    end
    ```

    `display` メソッドがアクションです。このアクションが呼び出されると、Railsは自動的に同名のビューファイル（この場合は `display.html.erb`）を探します。

3. **ビューの作成**: 対応するビューファイル（ERBファイル）を `app/views/home` ディレクトリ内に作成します。

    ```
    <!-- app/views/home/display.html.erb -->
    <!-- ここにHTMLとERBタグを書く -->
    ```

以上の設定が完了すれば、`http://[ドメイン]/home/display` にアクセスすると、`HomeController` の `display` アクションが呼び出され、`app/views/home/display.html.erb` ファイルがレンダリングされます。

この仕組みを利用して、ERBファイルを適切に表示することができます。何か不明点があれば、どうぞご質問ください。




Ruby on Railsで外部スクリプトを遅延実行する方法はいくつかありますが、簡単な方法としてはRubyの `sleep` メソッドを使用する方法があります。

```ruby
def open_pdf
  # ...（既存のコード）

  # 10秒待機
  sleep 10

  # 外部のRubyスクリプトを実行
  system("ruby C:/Users/s_k_t/pusher_test1010_app/config/download.rb")
end
```

この方法は単純ですが、注意点があります。`sleep` メソッドは、その間全ての処理を停止するので、他のリクエストが来た場合にも影響を与える可能性があります。

より本格的な実装を考えるならば、非同期のバックグラウンドジョブを使用する方法が一般的です。これには、`Sidekiq` や `Delayed::Job` のようなgemを使用します。

例えば `Sidekiq` を使用する場合:

1. Gemfileに `sidekiq` を追加し、`bundle install`を実行。
2. 新しいWorkerクラスを作成して、遅延実行するコードを記述。
3. コントローラーからそのWorkerを呼び出す。

このようにすると、非同期でタスクを実行でき、アプリケーションのパフォーマンスも維持できます。

このJavaScriptコードは、Webページが読み込まれた際に特定の処理を行います。
具体的には、PDFファイルをiframe内で表示し、一定時間後に別のPDFファイルに切り替え、
その後サーバーにDELETEメソッドでリクエストを送る、といった一連の処理が含まれています。

詳しく解説します。

1. **window.onload = function() { ... }**:
 ページが完全に読み込まれた後に処理を開始します。
  
2. **let contentFrame = document.getElementById("content");**:
 HTML内のidが"content"である要素（この場合はiframe）を取得して
 `contentFrame`変数に格納します。

3. **contentFrame.src = "/temp/default.pdf";**:
 iframeの`src`属性を`/temp/default.pdf`に設定し、このPDFを表示します。

4. **setTimeout(function() { ... }, 10000);**:
 10秒後（10000ミリ秒後）に指定した関数を実行します。

  - **contentFrame.src = "/temp/download.pdf";**:
   10秒後にiframeの`src`を`/temp/download.pdf`に変更します。
  
  - **contentFrame.onload = function() { ... };**:
   `src`が変更されて新しいPDFが読み込まれた後に、この関数が呼び出されます。
  
    - **fetch('/delete_pdf', { method: 'DELETE' })**: 
    サーバーの`/delete_pdf`エンドポイントにDELETEメソッドでリクエストを送ります。
    
    - **.then(() => { ... })**:
     リクエストが成功した場合の処理。ここではコンソールに"delete_pdf成功"と出力されます。
    
    - **.catch(() => { ... })**: 
    リクエストが失敗した場合の処理。"delete_pdf失敗"とコンソールに出力し、`src`を`/temp/default.pdf`に戻します。

このように、コードは非常に線形であり、各ステップが明確に定義されています。主な動作は、ページの読み込みが完了したらPDFを表示し、10秒後に別のPDFに切り替え、その読み込みが完了したらDELETEリクエストを送る、という流れです。






////////////////////////////10/16............................


プッシュ通知を使用すると、サーバーからクライアントへの通信が効率的になり、新しいPDFが生成された瞬間にクライアントがそれを知ることができます。これは、クライアントが一定間隔でサーバーにリクエストを送るポーリングよりも効率的です。

プッシュ通知の一例として、WebSocketを使う方法があります。RailsではActionCableというライブラリでWebSocketを簡単に扱うことができます。

以下は、ActionCableを用いた基本的な実装のスケッチです。

### サーバー側（Ruby on Rails）

1. `app/channels/application_cable/connection.rb` を設定します。

    ```ruby
    module ApplicationCable
      class Connection < ActionCable::Connection::Base
      end
    end
    ```

2. 新しいチャンネルを作成します。この例では `PdfChannel` とします。

    ```bash
    rails generate channel Pdf
    ```

3. 生成された `app/channels/pdf_channel.rb` を編集します。

    ```ruby
    class PdfChannel < ApplicationCable::Channel
      def subscribed
        stream_from "pdf_channel"
      end
    end
    ```

4. 新しいPDFが生成されたときにこのチャンネルを通じて通知を送ります。

    ```ruby
    ActionCable.server.broadcast "pdf_channel", message: 'new_pdf_generated'
    ```

### クライアント側（JavaScript）

1. ActionCableをセットアップします。

    ```javascript
    import consumer from "./consumer"

    consumer.subscriptions.create("PdfChannel", {
      received(data) {
        // 新しいPDFが生成されたときの処理
        if (data.message === 'new_pdf_generated') {
          document.getElementById("content").src = "/temp/download.pdf";
        }
      }
    });
    ```

これで、新しいPDFが生成された瞬間に、その情報がクライアントにプッシュされ、iframeの`src`が更新されるようになります。



PusherはWebSocketによるリアルタイム通信をサポートしていますが、通常のブラウザのプッシュ通知（通知バーに表示されるもの）とは異なります。Pusherを使用すると、サーバーからブラウザに
リアルタイムでデータを送ることができます。

Pusherで「OKボタンを押さないといけない」というのは、おそらくブラウザの通知APIを使っているからだと思われます。Pusher自体はそのような制約を持っていません。

JavaScriptでPusherを使ってリアルタイムにデータを受け取る例を以下に示します。

```javascript
// PusherのJavaScriptライブラリを読み込みます
var pusher = new Pusher('YOUR_PUSHER_APP_KEY', {
  cluster: 'YOUR_PUSHER_APP_CLUSTER'
});

// チャンネルに参加します
var channel = pusher.subscribe('my-channel');

// 'my-event'イベントを待ち受けます
channel.bind('my-event', function(data) {
  // 新しいPDFが生成されたときの処理
  if (data.message === 'new_pdf_generated') {
    document.getElementById("content").src = "/temp/download.pdf";
  }
});
```

このように設定すると、「OKボタンを押さないといけない」といった制約なく、サーバーからの通知をリアルタイムで受け取って処理を行うことができます。



プッシュ通知を使ってリアルタイムにPDFファイルが生成されたかどうかを確認するために、以下のような手順が考えられます。

### サーバーサイド（Ruby on Rails）

1. 新しいPDFが生成された際に、Pusherを使ってフロントエンドに通知を送ります。

    ```ruby
    # PDFが生成された後の処理
    begin
        Pusher.trigger('my-channel', 'my-event', { message: 'new_pdf_generated' })
        head :ok
    rescue => e
        render json: { error: "Pusherでエラーが発生しました: #{e.message}" }, status: :internal_server_error
    end
    ```

### フロントエンド（JavaScript）

1. Pusherの通知を受け取ったら、`/temp/download.pdf` を確認しに行き、存在する場合はそのPDFをiframeで表示します。

    ```javascript
    // PusherのJavaScriptライブラリを読み込み
    var pusher = new Pusher('YOUR_PUSHER_APP_KEY', {
      cluster: 'YOUR_PUSHER_APP_CLUSTER'
    });

    // チャンネルに参加
    var channel = pusher.subscribe('my-channel');

    // 'my-event'イベントを待ち受け
    channel.bind('my-event', function(data) {
      // 新しいPDFが生成されたときの処理
      if (data.message === 'new_pdf_generated') {
        // ここでPDFの存在を確認して、存在する場合はiframeで表示
        var contentFrame = document.getElementById("content");
        contentFrame.src = "/temp/download.pdf";
      }
    });
    ```

このようにすることで、新しいPDFが生成された際にリアルタイムでそのPDFをiframeで表示することができます。


Pusherに関するJavaScriptコードは、HTMLの`<body>`タグが閉じる直前に追加するのが一般的です。ただし、それはすでにある`<script>`タグの後に追加することが重要です。このようにすることで、ページが読み込まれたときにすべてのJavaScriptコードが正しく動作する確率が高くなります。

以下が修正後のコードです。

```html

  <body>
    <!-- 表示用　iframe-->
    <iframe id="content" src='/temp/default.pdf'></iframe>
    <script>
      // 既存のJavaScriptコード
      window.onload = function() {
        let contentFrame = document.getElementById("content");
        contentFrame.src = "/temp/default.pdf";
        // 以前のコード...
      };
    </script>
    <!-- ここにPusherのコードを追加 -->
    <script>
      var pusher = new Pusher('32f2640be6b94e4b6afe', {
        cluster: 'ap3'
      });
      var channel = pusher.subscribe('my-channel');
      channel.bind('my-event', function(data) {
        if (data.message === 'new_pdf_generated') {
          var contentFrame = document.getElementById("content");
          contentFrame.src = "/temp/download.pdf";
        }
      });
    </script>
  </body>
</html>
```

この修正により、Pusherを使用してサーバーからのプッシュ通知を受け取り、その通知に応じてPDFを表示する処理が追加されました。

























Rubyの`sleep`関数は、引数で指定した秒数だけプログラムの実行を停止します。
ただし、Ruby on Railsのコントローラ内で`sleep`を使うと、
その間ユーザーはレスポンスを受け取れずに待たされてしまいます。
これはあまり良いユーザーエクスペリエンスとは言えません。

また、`sleep(1000)`とすると、1000秒（約16.7分）プログラムが停止することになります。
秒数を調整する必要があります（10秒なら`sleep(10)`）。

このような遅延処理は、非同期処理やバックグラウンドジョブを用いて実装するのが一般的です。
Railsでは、`ActiveJob`というフレームワークがよく用いられます。

以下は`ActiveJob`を使った例です。

```ruby
# app/jobs/send_response_job.rb
class SendResponseJob < ApplicationJob
  queue_as :default

  def perform(file_id)
    if file_id
        render json: { message: "処理を開始します" }, status: :ok
    else
        render json: { error: "受信待ち" }, status: :bad_request
    end
  end
end
```

そして、コントローラー内でこのジョブを呼び出す方法は以下のとおりです。

```ruby
# app/controllers/home_controller.rb
def open_pdf
  # ...（省略）...

  # 10秒後にSendResponseJobを実行
  SendResponseJob.set(wait: 10.seconds).perform_later(@file_id)
end
```

このようにすると、10秒後に`SendResponseJob`が実行され、指定した処理が行われます。
この場合、ユーザーはその間に他の操作を行えます。



まず、`SendResponseJob`という新しいActiveJobを作成します。
このジョブは、`@file_id`に応じたJSONレスポンスを生成する役割を担います。

```ruby
# app/jobs/send_response_job.rb
class SendResponseJob < ApplicationJob
  queue_as :default

  def perform(file_id)
    if file_id
      # ここではrenderを直接使用できないため、何らかの手段（例えば、Pusher）を用いてクライアントに通知を送る
    else
      # こちらも同様
    end
  end
end
```

次に、`home_controller.rb`の`open_pdf`メソッドを修正します。
ここでは、`SendResponseJob`を10秒後に実行するようにスケジューリングします。

```ruby
# app/controllers/home_controller.rb
def open_pdf
  # ...（省略）...

  # その他の処理（例：PDFの生成など）

  # 10秒後にSendResponseJobを実行
  SendResponseJob.set(wait: 10.seconds).perform_later(@file_id)

  # 非同期処理をスケジュールした後は、即座に何らかのレスポンスを返す（ここでは例として200 OKを返しています）
  render json: { message: "Job is scheduled" }, status: :ok
end
```

このようにすることで、`open_pdf`メソッドが呼び出された後、
10秒後に`SendResponseJob`が実行されます。
このジョブ内で必要な処理（例えば、クライアントにPusherを使って通知を送るなど）を行えます。

ただし、`perform`メソッド内で`render`メソッドは使用できません。
この部分は、通常非同期通知の手段（例えば、Pusher）を使ってクライアントに結果を通知する形になります。

この説明が理解できましたでしょうか？何か質問や不明点があれば、どうぞお知らせください。



新しく作成されたPDFが表示されない、および `DELETE` メソッドが発動しないとのことですが、これは多くの原因が考えられます。

1. **新しく作成されたPDFが表示されない**: Pusherからの通知は正確に来ていますか？もし通知が来ている場合、JavaScript内での条件分岐（`if (data.message === 'new_pdf_generated')`）は正しく動作していますか？また、`/temp/download.pdf` が実際に存在するかどうかも確認してください。

2. **DELETE メソッドが発動しない**: `fetch('/delete_pdf', { method: 'DELETE' })` が呼び出されていない、またはエラーが発生している可能性があります。JavaScriptの `console.log` またはブラウザの開発者ツールを使用して、エラーが発生していないか確認してみてください。

3. **ルーティング**: あなたがアップロードした `display.html.erb` にJavaScriptのコードが含まれていましたが、このJavaScriptが実際に読み込まれて実行されているか確認してください。

以下は、Pusherを使用して新しく作成されたPDFを表示し、その後でPDFを削除するための一例です。

```html
<script>
  // Pusherの設定
  var pusher = new Pusher('YOUR_PUSHER_APP_KEY', {
    cluster: 'YOUR_PUSHER_APP_CLUSTER'
  });

  var channel = pusher.subscribe('my-channel');

  channel.bind('my-event', function(data) {
    if (data.message === 'new_pdf_generated') {
      var contentFrame = document.getElementById("content");
      contentFrame.src = "/temp/download.pdf";

      contentFrame.onload = function() {
        fetch('/delete_pdf', {
          method: 'DELETE'
        })
        .then(() => {
          console.log("delete_pdf成功");
        })
        .catch(() => {
          console.log("delete_pdf失敗");
        });
      };
    }
  });
</script>
```

このJavaScriptコードは、Pusherから `new_pdf_generated` というメッセージを受け取ったら、新しいPDFをiframeで表示し、そのPDFが読み込まれたらDELETEメソッドを発動してPDFを削除します。

このコードを `display.html.erb` の適切な場所（たとえば、既存のJavaScriptの後）に追加してみてください。そして、もう一度動作を確認してみてください。

何か疑問点があれば、お知らせください。






______






<!DOCTYPE html>

<%# :1013_test用.pdf
curl -X POST -H "Content-Type: application/json" -d "{""keycode"": ""download_SO1AZAhF9C1o7kaB52CK"", ""id"": ""1Cb3pJG-8A6LCY8XvlXl_vgCjPk9OoJxu""}" http://localhost:3000/open_pdf
 %>
<%# :ストレスケア
curl -X POST -H "Content-Type: application/json" -d "{""keycode"": ""download_SO1AZAhF9C1o7kaB52CK"", ""id"": ""1VXKVUAG5XiAp99-OLp5CUvGxwi3RvtY1""}" http://localhost:3000/open_pdf
 %>
<%#：待機画像
curl -X POST -H "Content-Type: application/json" -d "{""keycode"": ""download_SO1AZAhF9C1o7kaB52CK"", ""id"": ""1VXKVUAG5XiAp99-OLp5CUvGxwi3RvtY1""}" http://localhost:3000/open_pdf
%>

  <html>
    <head>
      <base target="_top">
        <style>
          * {
            margin: 0;
            padding: 0;
            overflow: hidden;
            height:100vh;
          }
          iframe {
            border:none;
            width:100%;
            height:100%;
          }
        </style>
    </head>

    <body>
      <!-- 表示用　iframe-->
      <iframe id="content" src='/temp/default.pdf'></iframe>
        <script>
          // 関数：PDFの表示と削除処理：ページが完全に読み込まれた後の処理
          window.onload = function() {
            // iframe要素を取得
            let contentFrame = document.getElementById("content");

            // 初期表示は/temp/default.pdf
            contentFrame.src = "/temp/default.pdf";

            // 指定時間後に実行する処理
            setTimeout(function() {
              // download.pdfが生成され、iframeのsrcを変更
              contentFrame.src = "/temp/download.pdf";

              // download.pdfがiframeに読み込まれたら、次の処理に移る
              contentFrame.onload = function() {
                // (/delete_pdf): DELETEメソッドでリクエスト送信
                fetch('/delete_pdf', {
                  method: 'DELETE'
                })
                .then(() => {
                  console.log("delete_pdf成功");
                })
                .catch(() => {
                  console.log("delete_pdf失敗");
                  // エラーが発生した場合は、default.pdfを再表示
                  contentFrame.src = "/temp/default.pdf";
                });
              };
             }, 10000); // 10秒：timde_set
          };
    </body>
  </html>

______